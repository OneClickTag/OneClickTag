import React from 'react';
import { useQuery, useMutation, useQueryClient, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query';
import { typedCustomerService } from '../services/typedCustomerService';
import { loadingManager } from '../loading/loadingManager';
import { errorHandler } from '../errors/errorHandler';
import { ApiError, ApiResponse } from '../types';
import { components } from '../generated/schema';

// Type helpers
type CustomerResponse = components['schemas']['Customer'];
type CreateCustomerRequest = components['schemas']['CreateCustomerRequest'];
type UpdateCustomerRequest = components['schemas']['UpdateCustomerRequest'];
type PaginatedCustomersResponse = components['schemas']['PaginatedCustomersResponse'];

// Query keys factory
export const customerKeys = {
  all: ['customers'] as const,
  lists: () => [...customerKeys.all, 'list'] as const,
  list: (filters: any) => [...customerKeys.lists(), filters] as const,
  details: () => [...customerKeys.all, 'detail'] as const,
  detail: (id: string) => [...customerKeys.details(), id] as const,
  analytics: (id: string) => [...customerKeys.detail(id), 'analytics'] as const,
  activities: (id: string) => [...customerKeys.detail(id), 'activities'] as const,
  stats: () => [...customerKeys.all, 'stats'] as const,
  search: (query: string) => [...customerKeys.all, 'search', query] as const,
};

// Hooks for customer queries
export function useCustomers(
  filters?: {
    page?: number;
    limit?: number;
    search?: string;
    status?: 'active' | 'inactive' | 'pending';
    tags?: string[];
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
  },
  options?: Omit<UseQueryOptions<ApiResponse<PaginatedCustomersResponse>>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: customerKeys.list(filters),
    queryFn: () => typedCustomerService.getCustomers(filters),
    staleTime: 5 * 60 * 1000, // 5 minutes
    ...options,
  });
}

export function useCustomer(
  id: string,
  options?: Omit<UseQueryOptions<ApiResponse<CustomerResponse>>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: customerKeys.detail(id),
    queryFn: () => typedCustomerService.getCustomer(id),
    enabled: !!id,
    staleTime: 5 * 60 * 1000, // 5 minutes
    ...options,
  });
}

export function useCustomerAnalytics(
  id: string,
  params?: {
    startDate?: string;
    endDate?: string;
    metrics?: string[];
  },
  options?: Omit<UseQueryOptions<ApiResponse<any>>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: customerKeys.analytics(id),
    queryFn: () => typedCustomerService.getCustomerAnalytics(id, params),
    enabled: !!id,
    staleTime: 2 * 60 * 1000, // 2 minutes
    ...options,
  });
}

export function useCustomerActivities(
  id: string,
  params?: {
    page?: number;
    limit?: number;
    activityType?: string;
    startDate?: string;
    endDate?: string;
  },
  options?: Omit<UseQueryOptions<ApiResponse<any>>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: customerKeys.activities(id),
    queryFn: () => typedCustomerService.getCustomerActivities(id, params),
    enabled: !!id,
    staleTime: 1 * 60 * 1000, // 1 minute
    ...options,
  });
}

export function useCustomerStats(
  params?: {
    startDate?: string;
    endDate?: string;
    groupBy?: 'day' | 'week' | 'month';
    includeComparison?: boolean;
  },
  options?: Omit<UseQueryOptions<ApiResponse<any>>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: customerKeys.stats(),
    queryFn: () => typedCustomerService.getCustomerStats(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
    ...options,
  });
}

// Mutation hooks
export function useCreateCustomer(
  options?: UseMutationOptions<
    ApiResponse<CustomerResponse>,
    ApiError,
    CreateCustomerRequest
  >
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateCustomerRequest) => 
      typedCustomerService.createCustomer(data),
    onSuccess: (data, variables) => {
      // Invalidate customer lists
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
      queryClient.invalidateQueries({ queryKey: customerKeys.stats() });
      
      // Optimistically update the cache with the new customer
      queryClient.setQueryData(
        customerKeys.detail(data.data.id),
        data
      );
    },
    onError: (error) => {
      errorHandler.handleError(error);
    },
    ...options,
  });
}

export function useUpdateCustomer(
  options?: UseMutationOptions<
    ApiResponse<CustomerResponse>,
    ApiError,
    { id: string; data: UpdateCustomerRequest }
  >
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }) => 
      typedCustomerService.updateCustomer(id, data),
    onSuccess: (data, variables) => {
      // Update the specific customer cache
      queryClient.setQueryData(
        customerKeys.detail(variables.id),
        data
      );
      
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
      queryClient.invalidateQueries({ queryKey: customerKeys.analytics(variables.id) });
    },
    onError: (error) => {
      errorHandler.handleError(error);
    },
    ...options,
  });
}

export function useDeleteCustomer(
  options?: UseMutationOptions<
    ApiResponse<void>,
    ApiError,
    string
  >
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (id: string) => 
      typedCustomerService.deleteCustomer(id),
    onSuccess: (data, id) => {
      // Remove customer from cache
      queryClient.removeQueries({ queryKey: customerKeys.detail(id) });
      
      // Invalidate lists and stats
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
      queryClient.invalidateQueries({ queryKey: customerKeys.stats() });
    },
    onError: (error) => {
      errorHandler.handleError(error);
    },
    ...options,
  });
}

export function useBulkDeleteCustomers(
  options?: UseMutationOptions<
    ApiResponse<{ deleted: number; failed: string[] }>,
    ApiError,
    string[]
  >
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (ids: string[]) => 
      typedCustomerService.bulkDeleteCustomers({ ids }),
    onSuccess: (data, ids) => {
      // Remove deleted customers from cache
      ids.forEach(id => {
        queryClient.removeQueries({ queryKey: customerKeys.detail(id) });
      });
      
      // Invalidate lists and stats
      queryClient.invalidateQueries({ queryKey: customerKeys.lists() });
      queryClient.invalidateQueries({ queryKey: customerKeys.stats() });
    },
    onError: (error) => {
      errorHandler.handleError(error);
    },
    ...options,
  });
}

export function useConnectGoogleAccount(
  options?: UseMutationOptions<
    ApiResponse<any>,
    ApiError,
    { id: string; authCode: string }
  >
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, authCode }) => 
      typedCustomerService.connectGoogleAccount(id, { authCode }),
    onSuccess: (data, variables) => {
      // Invalidate customer data to refresh Google connection status
      queryClient.invalidateQueries({ 
        queryKey: customerKeys.detail(variables.id) 
      });
    },
    onError: (error) => {
      errorHandler.handleError(error);
    },
    ...options,
  });
}

export function useUploadCustomerAvatar(
  options?: UseMutationOptions<
    ApiResponse<any>,
    ApiError,
    { id: string; file: File }
  >
) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, file }) => 
      typedCustomerService.uploadAvatar(id, file),
    onSuccess: (data, variables) => {
      // Update customer data with new avatar
      queryClient.invalidateQueries({ 
        queryKey: customerKeys.detail(variables.id) 
      });
    },
    onError: (error) => {
      errorHandler.handleError(error);
    },
    ...options,
  });
}

// Specialized hooks for common operations
export function useCustomerSearch(
  query: string,
  options?: Omit<UseQueryOptions<ApiResponse<any>>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: customerKeys.search(query),
    queryFn: () => typedCustomerService.getCustomers({
      search: query,
      limit: 20,
    }),
    enabled: query.length >= 2,
    staleTime: 30 * 1000, // 30 seconds
    ...options,
  });
}

// Hook for email availability check with debouncing
export function useEmailAvailability(
  email: string,
  excludeId?: string,
  options?: Omit<UseQueryOptions<ApiResponse<any>>, 'queryKey' | 'queryFn'>
) {
  return useQuery({
    queryKey: ['customer-email-check', email, excludeId],
    queryFn: () => typedCustomerService.checkEmailAvailability(email, excludeId),
    enabled: !!email && email.includes('@'),
    staleTime: 5 * 60 * 1000, // 5 minutes
    ...options,
  });
}

// Hook for optimistic updates with error rollback
export function useOptimisticCustomerUpdate() {
  const queryClient = useQueryClient();
  const updateMutation = useUpdateCustomer();

  const optimisticUpdate = async (
    id: string, 
    updates: Partial<CustomerResponse>,
    mutationData: UpdateCustomerRequest
  ) => {
    // Cancel outgoing queries
    await queryClient.cancelQueries({ queryKey: customerKeys.detail(id) });

    // Get current data
    const previousData = queryClient.getQueryData<ApiResponse<CustomerResponse>>(
      customerKeys.detail(id)
    );

    // Optimistically update
    if (previousData) {
      queryClient.setQueryData<ApiResponse<CustomerResponse>>(
        customerKeys.detail(id),
        {
          ...previousData,
          data: {
            ...previousData.data,
            ...updates,
          },
        }
      );
    }

    // Perform mutation
    try {
      await updateMutation.mutateAsync({ id, data: mutationData });
    } catch (error) {
      // Rollback on error
      if (previousData) {
        queryClient.setQueryData(customerKeys.detail(id), previousData);
      }
      throw error;
    }
  };

  return {
    optimisticUpdate,
    isLoading: updateMutation.isPending,
    error: updateMutation.error,
  };
}

// Loading state hooks
export function useCustomerLoadingStates() {
  const [loadingStates, setLoadingStates] = React.useState<Record<string, boolean>>({});

  React.useEffect(() => {
    const unsubscribe = loadingManager.addListener((states, isGlobalLoading) => {
      // Filter for customer-related loading states
      const customerLoadingStates = Object.keys(states)
        .filter(key => key.includes('customer'))
        .reduce((acc, key) => ({
          ...acc,
          [key]: states[key],
        }), {});

      setLoadingStates(customerLoadingStates);
    });

    return unsubscribe;
  }, []);

  return loadingStates;
}

// Error handling hooks
export function useCustomerErrors() {
  const [errors, setErrors] = React.useState<ApiError[]>([]);

  React.useEffect(() => {
    const unsubscribe = errorHandler.addListener((error) => {
      // Only track customer-related errors
      if (error.details?.url?.includes('/customers')) {
        setErrors(prev => [...prev.slice(-9), error]); // Keep last 10 errors
      }
    });

    return unsubscribe;
  }, []);

  const clearErrors = () => setErrors([]);

  return {
    errors,
    clearErrors,
    hasErrors: errors.length > 0,
    latestError: errors[errors.length - 1],
  };
}